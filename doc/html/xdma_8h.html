<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kintex-7: xdma/xdma.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kintex-7</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_1c64272130d509cdb89bf3690093e211.html">xdma</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xdma.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;linux/timer.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="xbasic__types_8h_source.html">xbasic_types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xdma__bdring_8h_source.html">xdma_bdring.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xdma__user_8h_source.html">xdma_user.h</a>&quot;</code><br/>
<code>#include &lt;<a class="el" href="xpmon__be_8h_source.html">xpmon_be.h</a>&gt;</code><br/>
</div>
<p><a href="xdma_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDma__Engine.html">Dma_Engine</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprivData.html">privData</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42074f36bbf40f6146fe294278e44eba"></a><!-- doxytag: member="xdma.h::XDMA_H" ref="a42074f36bbf40f6146fe294278e44eba" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XDMA_H</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#a11bdbeb0f844db1d203f2b8f6f29ca5c">MAX_BARS</a>&#160;&#160;&#160;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#ad1d536723680fda5a728715495851220">MAX_DMA_ENGINES</a>&#160;&#160;&#160;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#a6c5ee535731a1e4b2b1429c9eed90e32">DMA_ALL_BDS</a>&#160;&#160;&#160;0xFFFFFFFF</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization and control functions in xdma.c</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#ad5d703a389553efc7322a29711908ca4">descriptor_init</a> (struct pci_dev *pdev, <a class="el" href="structDma__Engine.html">Dma_Engine</a> *eptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#a81c8783e19a2f1f2c50f8273b286c50d">descriptor_free</a> (struct pci_dev *pdev, <a class="el" href="structDma__Engine.html">Dma_Engine</a> *eptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#aa54ebea9ca5df43d8b76583c42272ed6">Dma_Initialize</a> (<a class="el" href="structDma__Engine.html">Dma_Engine</a> *InstancePtr, u32 BaseAddress, u32 Type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#aa95c53b30b03661caea5e5c1279acd58">Dma_Reset</a> (<a class="el" href="structDma__Engine.html">Dma_Engine</a> *InstancePtr)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2923477e4b3931dc631a624bfc97790"></a><!-- doxytag: member="xdma.h::DriverState" ref="af2923477e4b3931dc631a624bfc97790" args="" -->
u32&#160;</td><td class="memItemRight" valign="bottom"><b>DriverState</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d906e2e80eb931bf45239006e5ae4c5"></a><!-- doxytag: member="xdma.h::DmaLock" ref="a3d906e2e80eb931bf45239006e5ae4c5" args="" -->
spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><b>DmaLock</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bba5be6945e282eef3a3b0e271f526d"></a><!-- doxytag: member="xdma.h::DmaTXLock" ref="a4bba5be6945e282eef3a3b0e271f526d" args="" -->
spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><b>DmaTXLock</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c150d9b037851f34dca7fb81aef350"></a><!-- doxytag: member="xdma.h::DmaRXLock" ref="a95c150d9b037851f34dca7fb81aef350" args="" -->
spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><b>DmaRXLock</b></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private per-device data</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The PCI device entry points to this as driver-private data. In some cases, pointer back to PCI device entry is also required. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structprivData.html">privData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma_8h.html#aafe97d27b1b23279ec57b4c8f64d2369">dmaData</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The Xilinx Scatter Gather DMA driver for the Northwest Logic DMA Engine. Each DMA engine may either be for TX (System-to-Card or S2C) or RX (Card-to- System or C2S) operation. Each driver instance supports one S2C and one C2S DMA engines, allowing full-duplex operation per instance.</p>
<p>Please note that the Xilinx DMA driver uses only the Packet DMA engine of the Northwest Logic DMA Engine, and not the Block DMA engine type. As such, the description below pertains to the Packet DMA flow.</p>
<p>This component is designed to be used as a basic building block for designing a device driver. It provides register accesses such that all DMA processing can be maintained easier, but the device driver designer must still understand all the details of the DMA channel.</p>
<p>For a full description of DMA features, please see the hardware specification. This driver supports the following features:</p>
<ul>
<li>Scatter-Gather DMA (SGDMA)</li>
<li>Interrupts</li>
<li>Interrupts are coalesced by the driver to improve performance</li>
<li>32-bit addressing for <a class="el" href="structBuffer.html">Buffer</a> Descriptors (BDs) and data buffers</li>
<li>APIs to manage BD movement to and from the SGDMA engine</li>
<li>Virtual memory support</li>
<li>PCI Express support</li>
<li>Performance measurement statistics</li>
<li>APIs to enable DMA driver to be used by other application drivers</li>
</ul>
<p><b>Packet DMA Transactions</b></p>
<p>To describe a DMA transaction in its simplest form, you need source address, destination address, and the number of bytes to transfer. When using a packet DMA receive channel, the source address is within some piece of IP hardware and doesn't require the software to explicitly set it. And the destination address points to a system buffer into which received data must be copied.</p>
<p>Likewise, with a packet DMA transmit channel, the destination address is within the hardware and need not be specified by the software. And the source address points to a system buffer that must be transmitted.</p>
<p>Therefore, some of the packet DMA transaction attributes include:</p>
<ul>
<li>An application buffer address</li>
<li>The number bytes to transfer</li>
<li>Whether this transaction represents the start of a packet, or end of a packet, or neither (middle of a packet)</li>
</ul>
<p>The object used to describe a transaction is referred to as a <a class="el" href="structBuffer.html">Buffer</a> Descriptor (BD). See <a class="el" href="xdma__bd_8h.html">xdma_bd.h</a> for a detailed description of and the APIs for manipulation of these objects.</p>
<p><b>Scatter-Gather DMA (SGDMA)</b></p>
<p>SGDMA allows the application to define a list of transactions in memory which the hardware will process without further application intervention. During this time, the application is free to continue adding more work to keep the hardware busy.</p>
<p>Notification of completed transactions can be done either by polling the hardware, or using interrupts that signal a transaction has completed, or by examining BDs for a completion status.</p>
<p>SGDMA processes whole packets. A packet is defined as a series of data bytes that represent a message. SGDMA allows a packet of data to be broken up into one or more transactions. For example, take an Ethernet IP packet which consists of a 14-byte header followed by a data payload of one or more bytes. With SGDMA, the application may point a BD to the header and another BD to the payload, then transfer them as a single message. This strategy can make a TCP/IP stack more efficient by allowing it to keep packet headers and data in different memory regions instead of assembling packets into contiguous blocks of memory.</p>
<p><b>SGDMA Ring Management</b></p>
<p>The hardware expects BDs to be setup as a singly linked list. As a BD is completed, the DMA engine will dereference BD.Next and load the next BD to process. These BDs may be arranged in a large chain or in a large ring. This driver uses a fixed buffer ring where each BD is linked to the next BD in adjacent memory. The last BD in the ring is linked to the first.</p>
<p>Within the ring, the driver maintains four groups of BDs. Each group consists of 0 or more adjacent BDs:</p>
<ul>
<li>Free: Those BDs that can be allocated for DMA with <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a>.</li>
</ul>
<ul>
<li>Pre-process: Those BDs that have been allocated with <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a>. These BDs can now be modified in preparation for future DMA transactions.</li>
</ul>
<ul>
<li>Hardware: Those BDs that have been enqueued to hardware with <a class="el" href="xdma__bdring_8c.html#adc84047791402b3cd694e670aa6e2d69">Dma_BdRingToHw()</a>. These BDs are under hardware control and may be in a state of awaiting hardware processing, in process, or processed by hardware. It is considered an error for the driver to change BDs while they are in this group. Doing so can cause data corruption and lead to system instability.</li>
</ul>
<ul>
<li>Post-process: Those BDs that have been processed by hardware and have been recovered by the driver with <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a>. These BDs are now under driver control. The driver may access these BDs to determine the result of DMA transactions. When the driver is finished, <a class="el" href="xdma__bdring_8c.html#aad27432fbef9f2aea3af23a5a84bdc67">Dma_BdRingFree()</a> should be called to place them back into the Free group.</li>
</ul>
<p>Normally BDs are moved in the following way: </p>
<pre></pre><pre>         <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a>                      <a class="el" href="xdma__bdring_8c.html#adc84047791402b3cd694e670aa6e2d69">Dma_BdRingToHw()</a>
   Free ------------------------&gt; Pre-process ----------------------&gt; Hardware
                                                                      |
    /|\                                                               |
     |   <a class="el" href="xdma__bdring_8c.html#aad27432fbef9f2aea3af23a5a84bdc67">Dma_BdRingFree()</a>                       <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a>    |
     +--------------------------- Post-process &lt;----------------------+</pre><pre> </pre><p>There are a few exceptions to the flow above. One is that after BDs are moved from the Free group to the Pre-process group, the driver decides for whatever reason that these BDs are not ready and could not be given to hardware. In this case, these BDs could be moved back to Free group using <a class="el" href="xdma__bdring_8c.html#a5a5400d1d2eeb0c4637e91710c8e72de">Dma_BdRingUnAlloc()</a> function to help keep the BD ring in great shape and recover the error. See comments of the function for details.</p>
<pre></pre><pre>           <a class="el" href="xdma__bdring_8c.html#a5a5400d1d2eeb0c4637e91710c8e72de">Dma_BdRingUnAlloc()</a>
   Free &lt;----------------------- Pre-process</pre><pre> </pre><p>The second exception to the flow above is when a registered application-specific driver unregisters from the DMA driver, then the buffers queued for DMA must be retrieved from the BD ring and returned to the driver for freeing. This is the only time that this flow is used.</p>
<pre></pre><pre>         <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a>                      <a class="el" href="xdma__bdring_8c.html#adc84047791402b3cd694e670aa6e2d69">Dma_BdRingToHw()</a>
   Free ------------------------&gt; Pre-process ----------------------&gt; Hardware
                                                                        |
    /|\                                                                 |
     |   <a class="el" href="xdma__bdring_8c.html#aad27432fbef9f2aea3af23a5a84bdc67">Dma_BdRingFree()</a>                       <a class="el" href="xdma__bdring_8c.html#ab10eaf6ff93b286d06e9b0957fb4c948">Dma_BdRingForceFromHw()</a> |
     +--------------------------- Post-process &lt;------------------------+</pre><pre> </pre><p>The API provides macros that allow BD list traversal. These macros should be used with care as they do not understand where one group ends and another begins.</p>
<p>The driver does not cache or keep copies of any BD. When it modifies BDs returned by <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a> or <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a>, it is modifying the same BD that hardware accesses.</p>
<p>Certain pairs of list modification functions have usage restrictions. See the function headers for <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a> and <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a> for more information.</p>
<p><b>SGDMA Descriptor Ring Creation</b></p>
<p>During initialization, the function <a class="el" href="xdma__bdring_8c.html#a1f28b96e062f1a3cdff55a42f712116a">Dma_BdRingCreate()</a> is used to set up a memory block to contain all BDs for the DMA channel. This function takes as an argument the number of BDs to place in the list.</p>
<p>The caller allocates a memory block large enough to contain the desired number of BDs plus an extra one to take care of any shifting in order to meet the 32-byte alignment needs of the Northwest Logic DMA hardware. This has been covered in more detail below.</p>
<p>Once the list has been created, it can be used right away to perform DMA transactions.</p>
<p><b>Interrupts</b></p>
<p>The driver has a compile-time flag to enable either interrupts or polled mode of operation. In some configurations, the polled mode is seen to have better performance than the interrupt mode driver.</p>
<p>When interrupts are enabled, the interrupt handler !!!MUST!!! clear pending interrupts before handling the BDs processed by the DMA engine. Otherwise the following corner case could raise some issue:</p>
<ul>
<li>A packet is transmitted(/received) and asserts a TX(/RX) interrupt, and if this interrupt handler deals with the BDs finished by the DMA before it clears the interrupt, another packet could get transmitted(/received) and assert the interrupt between when the BDs are taken care and when the interrupt clearing operation begins, and the interrupt clearing operation will clear the interrupt raised by the second packet and will never process it according BDs until a new interrupt occurs.</li>
</ul>
<p>Changing the sequence to "Clear interrupts before handling BDs" solves this issue:</p>
<ul>
<li>If the interrupt raised by the second packet is before the interrupt clearing operation, the descriptors associated with the second packet must have been finished by hardware and ready for the handler to deal with, and those descriptors will processed with those BDs of the first packet during the handling of the interrupt asserted by the first packet.</li>
</ul>
<ul>
<li>if the interrupt of the second packet is asserted after the interrupt clearing operation but its BDs are finished before the handler starts to deal with BDs, the packet's buffer descriptors will be handled with those of the first packet during the handling of the interrupt asserted by the first packet.</li>
</ul>
<ul>
<li>Otherwise, the BDs of the second packet is not ready when the interrupt handler starts to deal with the BDs of the first packet. Those BDs will be handled next time the interrupt handled gets invoked as the interrupt of the second packet is not cleared in current pass and thereby will cause the handler to get invoked again</li>
</ul>
<p>Please note if the second case above occurs, the handler will find NO buffer descriptor is finished by the hardware (i.e., <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a> returns 0) during the handling of the interrupt asserted by the second packet. This is valid and the driver should NOT consider this is a hardware error and have no need to reset the hardware.</p>
<p><b>Interrupt Coalescing</b></p>
<p>On a high-speed link, significant processor overhead may be used in servicing interrupts. Interrupt coalescing can be achieved by the driver enabling BD completion interrupts, not on every BD, but on a set of BDs, thus reducing the frequency of interrupts. The macro INT_COAL_CNT in <a class="el" href="xdma__hw_8h.html">xdma_hw.h</a> can be used for this purpose.</p>
<p>In addition, the driver processes outstanding BDs to be processed after an idle timeout with no transactions elapses.</p>
<p><b> Software Initialization </b></p>
<p>The driver does the following steps in order to prepare the DMA engine to be ready to process DMA transactions:</p>
<ul>
<li>DMA Initialization using <a class="el" href="xdma_8c.html#aa54ebea9ca5df43d8b76583c42272ed6">Dma_Initialize()</a> function. This step initializes a driver instance for the given DMA engine and resets the engine. One driver instance exists for a pair of (S2C and C2S) engines.</li>
<li>BD Ring creation. A BD ring is needed per engine and can be built by calling <a class="el" href="xdma__bdring_8c.html#a1f28b96e062f1a3cdff55a42f712116a">Dma_BdRingCreate()</a>. A parameter passed to this function is the number of BDs fit in a given memory range, and Dma_mBdRingCntCalc() helps calculate the value.</li>
<li>(RX channel only) Prepare BDs with attached data buffers and give them to the RX channel. First, allocate BDs using <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a>, then populate data buffer address, data buffer size and the control word fields of each allocated BD with valid values. Last call <a class="el" href="xdma__bdring_8c.html#adc84047791402b3cd694e670aa6e2d69">Dma_BdRingToHw()</a> to give the BDs to the channel.</li>
<li>Enable interrupts if interrupt mode is chosen. The application is responsible for setting up the interrupt system, which includes providing and connecting interrupt handlers and call back functions, before the interrupts are enabled.</li>
<li>Start DMA channels: Call <a class="el" href="xdma__bdring_8c.html#a77800843381096be543f854420a69769">Dma_BdRingStart()</a> to start a channel</li>
</ul>
<p><b> How to start DMA transactions </b></p>
<p>RX channel is ready to start RX transactions once the initialization (see Initialization section above) is finished. The DMA transactions are triggered by the user IP (like Local Link TEMAC).</p>
<p>Starting TX transactions needs some work. The application calls <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a> to allocate a BD list, then populates necessary attributes of each allocated BD including data buffer address, data size, and control word, and last passes those BDs to the TX channel (see <a class="el" href="xdma__bdring_8c.html#adc84047791402b3cd694e670aa6e2d69">Dma_BdRingToHw()</a>). The added BDs will be processed as soon as the TX channel reaches them.</p>
<p><b> Software Post-Processing on completed DMA transactions </b></p>
<p>Some software post-processing is needed after DMA transactions are finished.</p>
<p>If interrupts are set up and enabled, DMA channels notify the software the finishing of DMA transactions using interrupts, Otherwise the application could poll the channels (see <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a>).</p>
<ul>
<li>Once BDs are finished by a channel, the application first needs to fetch them from the channel (see <a class="el" href="xdma__bdring_8c.html#ab85128ed7e74275d698cb0d87bdeee93">Dma_BdRingFromHw()</a>).</li>
<li>On TX side, the application now could free the data buffers attached to those BDs as the data in the buffers has been transmitted.</li>
<li>On RX side, the application now could use the received data in the buffers attached to those BDs</li>
<li>For both channels, those BDs need to be freed back to the Free group (see <a class="el" href="xdma__bdring_8c.html#aad27432fbef9f2aea3af23a5a84bdc67">Dma_BdRingFree()</a>) so they are allocatable for future transactions.</li>
<li>On RX side, it is the application's responsibility for having BDs ready to receive data at any time. Otherwise the RX channel will refuse to accept any data once it runs out of RX BDs. As we just freed those hardware completed BDs in the previous step, it is good timing to allocate them back (see <a class="el" href="xdma__bdring_8c.html#a26d30c4bf47c96018dd97fb76d9f389c">Dma_BdRingAlloc()</a>), prepare them, and feed them to the RX channel again (see <a class="el" href="xdma__bdring_8c.html#adc84047791402b3cd694e670aa6e2d69">Dma_BdRingToHw()</a>)</li>
</ul>
<p><b>Address Translation</b></p>
<p>When the BD list is setup with <a class="el" href="xdma__bdring_8c.html#a1f28b96e062f1a3cdff55a42f712116a">Dma_BdRingCreate()</a>, a physical and virtual address is supplied for the segment of memory containing the descriptors. The driver will handle any translations internally. Subsequent access of descriptors by the application is done in terms of their virtual address.</p>
<p>Any application data buffer address attached to a BD must be physical address. The application is responsible for calculating the physical address before assigns it to the buffer address field in the BD.</p>
<p><b> Memory Barriers </b></p>
<p>The DMA hardware expects the update to its Next BD pointer register to be the event which initiates DMA processing. Hence, memory barrier wmb() calls have been used to ensure this.</p>
<p><b>Alignment</b></p>
<p><b> For BDs: </b> The Northwest Logic DMA hardware requires BDs to be aligned at 32-byte boundaries. In addition to the this, the driver has its own alignment requirements. It needs to store per-packet information in each BD, for example, the buffer virtual address. In order to do this, the software view of the BD may be larger than the hardware view of the BD. For example, DMA_BD_SW_NUM_WORDS can be set to 16 words (64 bytes), even though DMA_BD_HW_NUM_WORDS is 8 words (32 bytes). Due to this, the driver gets additional space in which to store per-BD private information.</p>
<p>Minimum alignment is defined by the constant DMA_BD_MINIMUM_ALIGNMENT. This is the smallest alignment allowed by both hardware and software for them to properly work. Other than DMA_BD_MINIMUM_ALIGNMENT, multiples of the constant are the only valid alignments for BDs.</p>
<p>If the descriptor ring is to be placed in cached memory, alignment also MUST be at least the processor's cache-line size. If this requirement is not met then system instability will result. This is also true if the length of a BD is longer than one cache-line, in which case multiple cache-lines are needed to accommodate each BD.</p>
<p>Aside from the initial creation of the descriptor ring (see <a class="el" href="xdma__bdring_8c.html#a1f28b96e062f1a3cdff55a42f712116a">Dma_BdRingCreate()</a>), there are no other run-time checks for proper alignment.</p>
<p><b>For application data buffers:</b> Application data buffer alignment is taken care of by the application-specific drivers.</p>
<p><b>Reset After Stopping</b></p>
<p>This driver is designed to allow for stop-reset-start cycles of the DMA hardware while keeping the BD list intact. When restarted after a reset, this driver will point the DMA engine to where it left off after stopping it.</p>
<p>It is possible to load an application-specific driver, run it for some time, and then unload it. Without unloading the DMA driver as well, it should be possible to load another instance of the application-specific driver and it should work fine.</p>
<p>MODIFICATION HISTORY:</p>
<p>Ver Date Changes ----- -------- ------------------------------------------------------- 1.0 05/15/12 First version </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6c5ee535731a1e4b2b1429c9eed90e32"></a><!-- doxytag: member="xdma.h::DMA_ALL_BDS" ref="a6c5ee535731a1e4b2b1429c9eed90e32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMA_ALL_BDS&#160;&#160;&#160;0xFFFFFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates all valid BDs </p>

</div>
</div>
<a class="anchor" id="a11bdbeb0f844db1d203f2b8f6f29ca5c"></a><!-- doxytag: member="xdma.h::MAX_BARS" ref="a11bdbeb0f844db1d203f2b8f6f29ca5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BARS&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum number of BARs </p>

</div>
</div>
<a class="anchor" id="ad1d536723680fda5a728715495851220"></a><!-- doxytag: member="xdma.h::MAX_DMA_ENGINES" ref="ad1d536723680fda5a728715495851220" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_DMA_ENGINES&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum number of DMA engines </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a81c8783e19a2f1f2c50f8273b286c50d"></a><!-- doxytag: member="xdma.h::descriptor_free" ref="a81c8783e19a2f1f2c50f8273b286c50d" args="(struct pci_dev *pdev, Dma_Engine *eptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descriptor_free </td>
          <td>(</td>
          <td class="paramtype">struct pci_dev *&#160;</td>
          <td class="paramname"><em>pdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDma__Engine.html">Dma_Engine</a> *&#160;</td>
          <td class="paramname"><em>eptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In order to free allocated space (and avoid memory leaks), this function is called when the user driver unregisters itself from the DMA base driver. It does the following -</p>
<ul>
<li>Forcibly retrieves the buffers which have been queued up for DMA with the DMA engine hardware</li>
<li>Unmaps these buffers from the PCI/PCIe space</li>
<li>Returns these buffers to the user driver, which will free them</li>
<li>Frees the BD ring</li>
<li>De-allocates the space used for the BD ring, and unmaps it from the PCI/PCIe space</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdev</td><td>is the PCI/PCIe device instance </td></tr>
    <tr><td class="paramname">eptr</td><td>is a pointer to the DMA engine instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>References <a class="el" href="structDma__Engine.html#a908c7a2313424f11f5b61ba6bc3bdffc">Dma_Engine::BdRing</a>, <a class="el" href="structPktBuf.html#a87fb8738bfe6eb767d62cadef8c802f9">PktBuf::bufInfo</a>, <a class="el" href="structDma__Engine.html#a7ed1d5a9aff66c921cc1c0e23340c41d">Dma_Engine::delta</a>, <a class="el" href="structDma__Engine.html#a1d203a4399c0581eb6076353fc119867">Dma_Engine::descSpacePA</a>, <a class="el" href="structDma__Engine.html#a81769af379549f3f7bb394edc23f3680">Dma_Engine::descSpaceSize</a>, <a class="el" href="structDma__Engine.html#a513bd3f067b6442586507f942fb66dcf">Dma_Engine::descSpaceVA</a>, <a class="el" href="xdma__base_8c.html#a159615db93c9e1b511dd0032a273f83f">DMA_BD_CNT</a>, <a class="el" href="xdma__bdring_8c.html#ab10eaf6ff93b286d06e9b0957fb4c948">Dma_BdRingForceFromHw()</a>, <a class="el" href="xdma__bdring_8c.html#aad27432fbef9f2aea3af23a5a84bdc67">Dma_BdRingFree()</a>, <a class="el" href="xdma__bd_8h.html#a83d2a764ff67108b26f180d56a4c89f1">Dma_mBdGetBufAddr</a>, <a class="el" href="xdma__bd_8h.html#aae5d15301c8e0a3fd3aa4dabdc244b66">Dma_mBdGetCtrlLength</a>, <a class="el" href="xdma__bd_8h.html#a0f06be1b2e26328228c5da18b8e6543f">Dma_mBdGetId</a>, <a class="el" href="xdma__bdring_8h.html#a36f28d3f06160f0cb0bbb1b157580f8e">Dma_mBdRingNext</a>, <a class="el" href="xdma__bd_8h.html#a4fe1d45f35a07f3ed2da01790cf47a5b">Dma_mBdSetId</a>, <a class="el" href="structPktBuf.html#ae9a886f5f8e82480463ca54275b34d71">PktBuf::flags</a>, <a class="el" href="structDma__BdRing.html#a34fc2edc4af4dd44fca74e3b14632436">Dma_BdRing::IsRxChannel</a>, <a class="el" href="structPktBuf.html#ab5c6e4d7948b541120efb4bb46f03069">PktBuf::pageAddr</a>, <a class="el" href="xdma__user_8h.html#adacff076331c3710e34d5687c86c96df">PKT_UNUSED</a>, <a class="el" href="structPktBuf.html#a84f064bb9ca734326486a2da9584a86a">PktBuf::pktBuf</a>, <a class="el" href="structUserPtrs.html#afe89e8b90c431ce9f86587b56bfcd096">UserPtrs::privData</a>, <a class="el" href="structPktBuf.html#a36c05348038de53663b11f5c5aafce17">PktBuf::size</a>, <a class="el" href="structDma__Engine.html#a889ac212be067804cbec378b90a3c6a1">Dma_Engine::user</a>, <a class="el" href="structPktBuf.html#ac717ea327a8dd2d5b306d26169ab8b26">PktBuf::userInfo</a>, and <a class="el" href="structUserPtrs.html#a3f261a86422c62ce3011e8aac1b14d6d">UserPtrs::UserPutPkt</a>.</p>

<p>Referenced by <a class="el" href="xdma__user_8c.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d703a389553efc7322a29711908ca4"></a><!-- doxytag: member="xdma.h::descriptor_init" ref="ad5d703a389553efc7322a29711908ca4" args="(struct pci_dev *pdev, Dma_Engine *eptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int descriptor_init </td>
          <td>(</td>
          <td class="paramtype">struct pci_dev *&#160;</td>
          <td class="paramname"><em>pdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDma__Engine.html">Dma_Engine</a> *&#160;</td>
          <td class="paramname"><em>eptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes the DMA BD ring as follows -</p>
<ul>
<li>Calculates the space required by the DMA BD ring</li>
<li>Allocates the space, and aligns it as per DMA engine requirement</li>
<li>Creates the BD ring structure in the allocated space</li>
<li>If it is a RX DMA engine, allocates buffers from the user driver, and associates each BD in the RX BD ring with a buffer</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdev</td><td>is the PCI/PCIe device instance </td></tr>
    <tr><td class="paramname">eptr</td><td>is a pointer to the DMA engine instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful </dd>
<dd>
negative value if unsuccessful </dd></dl>

<p>References <a class="el" href="structDma__Engine.html#a908c7a2313424f11f5b61ba6bc3bdffc">Dma_Engine::BdRing</a>, <a class="el" href="structDma__Engine.html#a7ed1d5a9aff66c921cc1c0e23340c41d">Dma_Engine::delta</a>, <a class="el" href="structDma__Engine.html#a1d203a4399c0581eb6076353fc119867">Dma_Engine::descSpacePA</a>, <a class="el" href="structDma__Engine.html#a81769af379549f3f7bb394edc23f3680">Dma_Engine::descSpaceSize</a>, <a class="el" href="structDma__Engine.html#a513bd3f067b6442586507f942fb66dcf">Dma_Engine::descSpaceVA</a>, <a class="el" href="xdma__base_8c.html#a159615db93c9e1b511dd0032a273f83f">DMA_BD_CNT</a>, <a class="el" href="xdma__bd_8h.html#ab3de631133cf01079d4afda80b97671a">DMA_BD_MINIMUM_ALIGNMENT</a>, <a class="el" href="xdma__bd_8h.html#a17fbce0e86163ab65f9e7b77dbc5ea5d">DMA_BD_SW_NUM_WORDS</a>, <a class="el" href="xdma__bdring_8c.html#a77ecd1c1fcfb643ef3fbd0fa2840a6b4">Dma_BdRingAlign()</a>, <a class="el" href="xdma__bdring_8c.html#a1f28b96e062f1a3cdff55a42f712116a">Dma_BdRingCreate()</a>, <a class="el" href="xdma__hw_8h.html#a41e2e217156dc469aad7b4526df2c26a">DMA_ENG_C2S</a>, <a class="el" href="xdma__hw_8h.html#a4dff8d0a7e32e6b13491e12052f388b7">DMA_ENG_DIRECTION_MASK</a>, <a class="el" href="structDma__Engine.html#a612698b11c13741cff6226f9b28b5850">Dma_Engine::Type</a>, and <a class="el" href="structDma__Engine.html#a889ac212be067804cbec378b90a3c6a1">Dma_Engine::user</a>.</p>

<p>Referenced by <a class="el" href="xdma__user_8c.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a>.</p>

</div>
</div>
<a class="anchor" id="aa54ebea9ca5df43d8b76583c42272ed6"></a><!-- doxytag: member="xdma.h::Dma_Initialize" ref="aa54ebea9ca5df43d8b76583c42272ed6" args="(Dma_Engine *InstancePtr, u32 BaseAddress, u32 Type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dma_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDma__Engine.html">Dma_Engine</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes a DMA engine. This function must be called prior to using the DMA engine. Initialization of an engine includes setting up the register base address, setting up the instance data, and ensuring the hardware is in a quiescent state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the DMA engine instance to be worked on. </td></tr>
    <tr><td class="paramname">BaseAddress</td><td>is where the registers for this engine can be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>References <a class="el" href="structDma__Engine.html#a908c7a2313424f11f5b61ba6bc3bdffc">Dma_Engine::BdRing</a>, <a class="el" href="xdma__hw_8h.html#a41e2e217156dc469aad7b4526df2c26a">DMA_ENG_C2S</a>, <a class="el" href="xdma_8c.html#aa95c53b30b03661caea5e5c1279acd58">Dma_Reset()</a>, <a class="el" href="structDma__Engine.html#a4be2947a1ed70fe05e1f81931718e5b9">Dma_Engine::EngineState</a>, <a class="el" href="xdma__user_8h.html#a05b386d4bad60f6f9236de6d3be866e0">INITIALIZED</a>, <a class="el" href="structDma__BdRing.html#a34fc2edc4af4dd44fca74e3b14632436">Dma_BdRing::IsRxChannel</a>, <a class="el" href="structDma__Engine.html#a9b0aae4ccf485f4204eb3b52f9831051">Dma_Engine::RegBase</a>, <a class="el" href="structDma__BdRing.html#a540cdbb6a270d29c8761f1b7bc501a8c">Dma_BdRing::RunState</a>, and <a class="el" href="structDma__Engine.html#a612698b11c13741cff6226f9b28b5850">Dma_Engine::Type</a>.</p>

</div>
</div>
<a class="anchor" id="aa95c53b30b03661caea5e5c1279acd58"></a><!-- doxytag: member="xdma.h::Dma_Reset" ref="aa95c53b30b03661caea5e5c1279acd58" args="(Dma_Engine *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dma_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDma__Engine.html">Dma_Engine</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the DMA engine.</p>
<p>Should not be invoked during initialization stage because hardware has just come out of a system reset. Should be invoked during shutdown stage.</p>
<p>New BD fetches will stop immediately. Reset will be completed once the user logic completes its reset. DMA disable will be completed when the BDs already being processed are completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the DMA engine instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><ul>
<li>If the hardware is not working properly, and the self-clearing reset bits do not clear, this function will be terminated after a timeout. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xdma__hw_8h.html#a37910edf29311f45769405926ad155df">DMA_ENG_ALLINT_MASK</a>, <a class="el" href="xdma__hw_8h.html#aa70f01b87ef40158a47446e97178a724">DMA_ENG_DISABLE</a>, <a class="el" href="xdma__hw_8h.html#a061bcafaef1fba7222c2d9e2e0360372">DMA_ENG_INT_ACTIVE_MASK</a>, <a class="el" href="xdma__hw_8h.html#a5c1b4110e7a206f1069389047fa5b306">DMA_ENG_RESET</a>, <a class="el" href="xdma__hw_8h.html#afdb7ed8a43c5fc824ec304a9d9f6084b">DMA_ENG_STATE_MASK</a>, <a class="el" href="xdma__hw_8h.html#a18413b82dd90655671951e7ba010410e">DMA_ENG_USER_RESET</a>, <a class="el" href="xdma__hw_8h.html#adad32f115a24f9a40adb83ec0c23a806">Dma_mEngIntAck</a>, <a class="el" href="xdma__hw_8h.html#a25aec48cb84f6dc47a916af0fd470675">Dma_mEngIntDisable</a>, <a class="el" href="xdma__hw_8h.html#a8eb26add3d4bf0f08966d06eef797f55">Dma_mGetCrSr</a>, <a class="el" href="xdma__bdring_8h.html#ab9919719ea54bfeab2586cf06b316731">Dma_mGetRing</a>, <a class="el" href="xdma__hw_8h.html#aa6445c055757dd40f2df51355569b392">Dma_mSetCrSr</a>, and <a class="el" href="structDma__BdRing.html#a540cdbb6a270d29c8761f1b7bc501a8c">Dma_BdRing::RunState</a>.</p>

<p>Referenced by <a class="el" href="xdma_8h.html#aa54ebea9ca5df43d8b76583c42272ed6">Dma_Initialize()</a>, and <a class="el" href="xdma__user_8c.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="aafe97d27b1b23279ec57b4c8f64d2369"></a><!-- doxytag: member="xdma.h::dmaData" ref="aafe97d27b1b23279ec57b4c8f64d2369" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structprivData.html">privData</a>* <a class="el" href="xdma__base_8c.html#aafe97d27b1b23279ec57b4c8f64d2369">dmaData</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DMA driver state-related variables </p>

<p>Referenced by <a class="el" href="xdma__user_8c.html#a824084db65f9e70d7c8d33ab570cd01e">DmaBaseAddress()</a>, <a class="el" href="xdma__user_8c.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a>, and <a class="el" href="xdma__user_8c.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a>.</p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 18:55:49 for Kintex-7 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
