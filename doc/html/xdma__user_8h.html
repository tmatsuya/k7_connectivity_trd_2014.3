<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kintex-7: include/xdma_user.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kintex-7</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_63370a9b6c4b759c937d5aae9107f9d7.html">include</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">xdma_user.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="xpmon__be_8h_source.html">xpmon_be.h</a>&gt;</code><br/>
<code>#include &lt;linux/ethtool.h&gt;</code><br/>
<code>#include &lt;linux/delay.h&gt;</code><br/>
</div>
<p><a href="xdma__user_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktBuf.html">PktBuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUserState.html">UserState</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUserPtrs.html">UserPtrs</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af831e51670dd8c517526eb7abc373213"></a><!-- doxytag: member="xdma_user.h::XDMA_USER_H" ref="af831e51670dd8c517526eb7abc373213" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XDMA_USER_H</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69ebf8ef753297744e9550c1e60c6619"></a><!-- doxytag: member="xdma_user.h::STATUS_REG_OFFSET" ref="a69ebf8ef753297744e9550c1e60c6619" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STATUS_REG_OFFSET</b>&#160;&#160;&#160;0x9008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7beadafb6f0c8895e83871024521f5c9"></a><!-- doxytag: member="xdma_user.h::PERFORMANCE_MODE" ref="a7beadafb6f0c8895e83871024521f5c9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PERFORMANCE_MODE</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e33db95df6fa5bf372f30c26a3ecca8"></a><!-- doxytag: member="xdma_user.h::ETHERNET_APPMODE" ref="a2e33db95df6fa5bf372f30c26a3ecca8" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ETHERNET_APPMODE</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95caedecd205a96805750c93253e13b4"></a><!-- doxytag: member="xdma_user.h::RAWETHERNET_MODE" ref="a95caedecd205a96805750c93253e13b4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RAWETHERNET_MODE</b>&#160;&#160;&#160;2</td></tr>
<tr><td colspan="2"><div class="groupHeader">Driver and engine states.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#ac84b46f1f855c691d8d2c95a23768ad5">UNINITIALIZED</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#a05b386d4bad60f6f9236de6d3be866e0">INITIALIZED</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#a9c24e8534e32ca5c349ed6b2c6ce1609">USER_ASSIGNED</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#af633e59bd3235afc0e3ce5bb08376e39">UNREGISTERING</a>&#160;&#160;&#160;3</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet information set/read by the user drivers.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags match with the status reported by DMA. Additional flags should be assigned from available bits. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#ab93f8205e16349899df4d4b4524b1a84">PKT_SOP</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#afd9e0d6d67039ac06e40f61918951264">PKT_EOP</a>&#160;&#160;&#160;0x40000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#ad8b1dddd79f8f55b83b8ece45d491a6e">PKT_ERROR</a>&#160;&#160;&#160;0x10000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#adacff076331c3710e34d5687c86c96df">PKT_UNUSED</a>&#160;&#160;&#160;0x00004000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#a7e071abf95b75e2d2015a5e635061627">PKT_ALL</a>&#160;&#160;&#160;0x00800000</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization and control functions in xdma.c</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister</a> (int engine, int bar, <a class="el" href="structUserPtrs.html">UserPtrs</a> *uptr, int pktsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister</a> (void *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdma__user_8h.html#a824084db65f9e70d7c8d33ab570cd01e">DmaBaseAddress</a> (int bar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab8c2bf6429c266ea0a91b9366091282"></a><!-- doxytag: member="xdma_user.h::DmaMac_WriteReg" ref="aab8c2bf6429c266ea0a91b9366091282" args="(int offset, int data)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>DmaMac_WriteReg</b> (int offset, int data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16097e2c8f7114ae9e903ee316e32eab"></a><!-- doxytag: member="xdma_user.h::DmaMac_ReadReg" ref="a16097e2c8f7114ae9e903ee316e32eab" args="(int offset)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>DmaMac_ReadReg</b> (int offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a523ca84435034b7ffef8455cc18322"></a><!-- doxytag: member="xdma_user.h::DmaSendPages_Tx" ref="a0a523ca84435034b7ffef8455cc18322" args="(void *handle, PktBuf **pkts, int numpkts)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>DmaSendPages_Tx</b> (void *handle, <a class="el" href="structPktBuf.html">PktBuf</a> **pkts, int numpkts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9099e27a46b28c75f8312cb82818933e"></a><!-- doxytag: member="xdma_user.h::DmaSendPages" ref="a9099e27a46b28c75f8312cb82818933e" args="(void *handle, PktBuf **pkts, int numpkts)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>DmaSendPages</b> (void *handle, <a class="el" href="structPktBuf.html">PktBuf</a> **pkts, int numpkts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a4887f61ce11a3c112b861cd2651026"></a><!-- doxytag: member="xdma_user.h::DmaSendPkt" ref="a3a4887f61ce11a3c112b861cd2651026" args="(void *handle, PktBuf *pkts, int numpkts)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>DmaSendPkt</b> (void *handle, <a class="el" href="structPktBuf.html">PktBuf</a> *pkts, int numpkts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f734d179fd7daf2ce78707fae32b7c2"></a><!-- doxytag: member="xdma_user.h::Dma_get_ringparam" ref="a0f734d179fd7daf2ce78707fae32b7c2" args="(void *handle, struct ethtool_ringparam *ering)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>Dma_get_ringparam</b> (void *handle, struct ethtool_ringparam *ering)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file contains the data required for the interface between the base DMA driver (xdma) and the application-specific drivers, for example,</p>
<p>This interface has been architected in order to make it possible to easily substitute the application-specific drivers that come with this TRD with other application-specific drivers, without re-writing the common DMA-handling functionality.</p>
<p>Some xdma functions are called directly by the application-specific driver and some are callbacks registered by the application-specific driver, and are called by xdma.</p>
<pre>
 Application-Specific Driver                               xdma Driver
                               Driver Registration
                 ----------------------------------------------&gt;
                             Driver De-registration
                 ----------------------------------------------&gt;
                           Transmit Block/Packet Data 
                 ----------------------------------------------&gt;
                            Complete Initialization
                &lt;----------------------------------------------
                            Complete Driver Removal
                &lt;----------------------------------------------
                            Complete Interrupt Tasks
                &lt;----------------------------------------------
                             Get Packet <a class="el" href="structBuffer.html">Buffer</a> for RX
                &lt;----------------------------------------------
                               Return Packet <a class="el" href="structBuffer.html">Buffer</a> 
                &lt;----------------------------------------------
                                    Set State
                &lt;----------------------------------------------
                                    Get State
                &lt;----------------------------------------------
 </pre><p> <b> Driver Registration/De-registration </b></p>
<p>The application-specific drivers are dependent on the DMA driver and can be inserted as Linux kernel modules only after xdma has been loaded.</p>
<p>To register itself with xdma, the application-specific driver does the following, while specifying the engine number and BAR number it requires, a set of function callback pointers, and the minimum packet size it normally uses - </p>
<pre> Handle = <a class="el" href="xdma__user_8c.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister(int Engine, int Bar, UserPtrs * uptr, int PktSize)</a>; </pre><p> The application-specific driver requires to know the kernel logical address of the desired BAR in order to do any device-specific initializations that may be required. For example, the xgbeth driver requires to program the TEMAC and PHY registers, while the xaui driver requires to control the test configuration.</p>
<p>Before returning to the caller, <a class="el" href="xdma__user_8h.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a> will invoke the function callback registered to complete the initialization process, while specifying the BAR's logical address, and a private data pointer that was passed to it during registration. <a class="el" href="structprivData.html">privData</a> can be used by the user driver to differentiate between multiple <a class="el" href="xdma__user_8h.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a> invocations - </p>
<pre> (uptr-&gt;UserInit)(BARbase, <a class="el" href="structprivData.html">privData</a>); </pre><p> <b><em> Note: The application-specific driver's UserInit() function call must be written in such a way that it works fine even when the <a class="el" href="xdma__user_8h.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a> call is not yet complete. </em></b></p>
<p>If the registration process is successful, a handle is returned which should be used in all other function calls to xdma.</p>
<p>To unregister itself from xdma, the application-specific driver does the following, while passing the handle it received after registration - </p>
<pre> DmaUnregister(Handle); </pre><p> Before returning to the caller, <a class="el" href="xdma__user_8h.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a> will invoke the function callback registered to enable any device-specific programming to be done as part of the de-registration process. </p>
<pre> (uptr-&gt;UserRemove)(Handle, <a class="el" href="structprivData.html">privData</a>); </pre><p> Before returning to the caller, <a class="el" href="xdma__user_8h.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a> also returns all the packet buffers that had been passed to it for transmission or reception. Incase these buffers are still unused, they are flagged as PKT_UNUSED. </p>
<pre> (uptr-&gt;UserPutPkt)(Handle, <a class="el" href="structPktBuf.html">PktBuf</a> * pkts, int NumPkts, <a class="el" href="structprivData.html">privData</a>); </pre><p> <b><em> Note: UserRemove() is not being invoked in xdma v1.00, and will be added in the future. </em></b></p>
<p><b> <a class="el" href="structBuffer.html">Buffer</a> Handling </b></p>
<p>For better performance, the DMA driver always sets up large buffer descriptor (BD) rings, one for transmission and one for reception. The TX BD ring will be consumed only when there is data for transmission. The RX BD ring, on the other hand, will be entirely submitted for DMA in order to maximize performance.</p>
<p><b> Data Transmission </b></p>
<p>When the application-specific driver wants to transmit a data block or packet, it invokes the following, while passing an array of one or more packets to be transmitted - </p>
<pre> DmaSendPkt(Handle, PktBuf * pkts, int NumPkts); </pre><p> When data transmission is completed, the packet buffers will be returned to the application-specific driver by invoking the following - </p>
<pre> (uptr-&gt;UserPutPkt)(Handle, <a class="el" href="structPktBuf.html">PktBuf</a> * pkts, int NumPkts, <a class="el" href="structprivData.html">privData</a>); </pre><p> It is important to return these buffers to the application-specific driver even though they are TX packets, since they would need to be freed or re-used as the case may be.</p>
<p><b> Data Reception </b></p>
<p>The DMA driver needs to set up the complete BD ring with buffers ready for reception. Hence, it invokes the following, while specifying the number of packet buffers it wants, and their size - </p>
<pre> (uptr-&gt;UserGetPkt)(Handle, <a class="el" href="structPktBuf.html">PktBuf</a> * pkts, uint Size, int NumPkts, <a class="el" href="structprivData.html">privData</a>); </pre><p> As data reception happens and buffers get used, they are returned to the application-specific driver, by invoking the following - </p>
<pre> (uptr-&gt;UserPutPkt)(Handle, <a class="el" href="structPktBuf.html">PktBuf</a> * pkts, int NumPkts, <a class="el" href="structprivData.html">privData</a>); </pre><p> The DMA driver will again invoke UserGetPkt() in order to replenish the used BDs in its BD ring.</p>
<p><b> Interrupts </b></p>
<p>The DMA driver can operate in either a polled mode or interrupt-driven mode, by modifying a compile-time flag. The application-specific driver can optionally enable application-specific interrupts. When an interrupt occurs, the DMA driver will invoke the following, to enable handling of these interrupt events - </p>
<pre> (uptr-&gt;UserIntr)(Handle, <a class="el" href="structprivData.html">privData</a>); </pre><p> <b><em> Note: This callback is not being invoked by xdma v1.00, and will be added in the future. </em></b></p>
<p><b> Configuration, Status and Statistics </b></p>
<p>The Xilinx Performance Monitor GUI (xpmon) can be used to initiate a data transfer test and measure DMA payload and PCIe link performance. xdma invokes the following, while specifying whether loopback is enabled or not, and the minimum/maximum bounds of packet sizes - </p>
<pre> (uptr-&gt;UserSetState)(Handle, <a class="el" href="structUserState.html">UserState</a> * ustate, <a class="el" href="structprivData.html">privData</a>); </pre><p> The same callback is used to start a test, and to stop a test.</p>
<p>xdma invokes the following, in order to get current state of the application-specific driver - </p>
<pre> (uptr-&gt;UserGetState)(Handle, <a class="el" href="structUserState.html">UserState</a> * ustate, <a class="el" href="structprivData.html">privData</a>); </pre><p> Information regarding current test state, link state, total number of buffers is returned and can be displayed in the xpmon GUI.</p>
<p>MODIFICATION HISTORY:</p>
<p>Ver Date Changes ----- -------- ------------------------------------------------------- 1.0 5/15/12 First release </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a05b386d4bad60f6f9236de6d3be866e0"></a><!-- doxytag: member="xdma_user.h::INITIALIZED" ref="a05b386d4bad60f6f9236de6d3be866e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INITIALIZED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After probe </p>

<p>Referenced by <a class="el" href="xdma_8h.html#aa54ebea9ca5df43d8b76583c42272ed6">Dma_Initialize()</a>, <a class="el" href="xdma__user_8c.html#a824084db65f9e70d7c8d33ab570cd01e">DmaBaseAddress()</a>, <a class="el" href="xdma__user_8c.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a>, and <a class="el" href="xdma__user_8c.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e071abf95b75e2d2015a5e635061627"></a><!-- doxytag: member="xdma_user.h::PKT_ALL" ref="a7e071abf95b75e2d2015a5e635061627" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_ALL&#160;&#160;&#160;0x00800000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All fragments must be sent </p>

</div>
</div>
<a class="anchor" id="afd9e0d6d67039ac06e40f61918951264"></a><!-- doxytag: member="xdma_user.h::PKT_EOP" ref="afd9e0d6d67039ac06e40f61918951264" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_EOP&#160;&#160;&#160;0x40000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structBuffer.html">Buffer</a> is the end-of-packet </p>

</div>
</div>
<a class="anchor" id="ad8b1dddd79f8f55b83b8ece45d491a6e"></a><!-- doxytag: member="xdma_user.h::PKT_ERROR" ref="ad8b1dddd79f8f55b83b8ece45d491a6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_ERROR&#160;&#160;&#160;0x10000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Error while processing buffer </p>

</div>
</div>
<a class="anchor" id="ab93f8205e16349899df4d4b4524b1a84"></a><!-- doxytag: member="xdma_user.h::PKT_SOP" ref="ab93f8205e16349899df4d4b4524b1a84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_SOP&#160;&#160;&#160;0x80000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structBuffer.html">Buffer</a> is the start-of-packet </p>

</div>
</div>
<a class="anchor" id="adacff076331c3710e34d5687c86c96df"></a><!-- doxytag: member="xdma_user.h::PKT_UNUSED" ref="adacff076331c3710e34d5687c86c96df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_UNUSED&#160;&#160;&#160;0x00004000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structBuffer.html">Buffer</a> is being returned unused </p>

<p>Referenced by <a class="el" href="xdma__base_8c.html#a81c8783e19a2f1f2c50f8273b286c50d">descriptor_free()</a>.</p>

</div>
</div>
<a class="anchor" id="ac84b46f1f855c691d8d2c95a23768ad5"></a><!-- doxytag: member="xdma_user.h::UNINITIALIZED" ref="ac84b46f1f855c691d8d2c95a23768ad5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNINITIALIZED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>State at system start </p>

</div>
</div>
<a class="anchor" id="af633e59bd3235afc0e3ce5bb08376e39"></a><!-- doxytag: member="xdma_user.h::UNREGISTERING" ref="af633e59bd3235afc0e3ce5bb08376e39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNREGISTERING&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In the process of unregistering </p>

<p>Referenced by <a class="el" href="xdma__user_8c.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c24e8534e32ca5c349ed6b2c6ce1609"></a><!-- doxytag: member="xdma_user.h::USER_ASSIGNED" ref="a9c24e8534e32ca5c349ed6b2c6ce1609" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USER_ASSIGNED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Engine assigned to user </p>

<p>Referenced by <a class="el" href="xdma__user_8c.html#abdaa00f7453cce5fc24cb3ff3df4331a">DmaRegister()</a>, and <a class="el" href="xdma__user_8c.html#a4104c7117330f48cb334c5c08538ad8e">DmaUnregister()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a824084db65f9e70d7c8d33ab570cd01e"></a><!-- doxytag: member="xdma_user.h::DmaBaseAddress" ref="a824084db65f9e70d7c8d33ab570cd01e" args="(int bar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* DmaBaseAddress </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the DMA base address to the user driver</p>
<p>In 10G support, the MAC address registers are not mapped to MAC address space. The MAC address registers are mapped to the DMA address area. Hence, the user driver should know the DMA base address, so that it can access the MAC address registers to Set/Get MAC address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bar</td><td>is the BAR register the user driver wants to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DMABaseAddress </dd></dl>

<p>References <a class="el" href="structprivData.html#a40afec97f1c7a5c5e2a19295ba98c065">privData::baseVAddr</a>, <a class="el" href="xdma_8h.html#aafe97d27b1b23279ec57b4c8f64d2369">dmaData</a>, and <a class="el" href="xdma__user_8h.html#a05b386d4bad60f6f9236de6d3be866e0">INITIALIZED</a>.</p>

</div>
</div>
<a class="anchor" id="abdaa00f7453cce5fc24cb3ff3df4331a"></a><!-- doxytag: member="xdma_user.h::DmaRegister" ref="abdaa00f7453cce5fc24cb3ff3df4331a" args="(int engine, int bar, UserPtrs *uptr, int pktsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* DmaRegister </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUserPtrs.html">UserPtrs</a> *&#160;</td>
          <td class="paramname"><em>uptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pktsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function must be called by the user driver to register itself with the base DMA driver. After doing required checks to verify the choice of engine and BAR register, it initializes the engine and the BD ring associated with the engine, and enables interrupts if required.</p>
<p>Only one user is supported per engine at any given time. Incase the engine has already been registered with another user driver, an error will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">engine</td><td>is the DMA engine the user driver wants to use. </td></tr>
    <tr><td class="paramname">bar</td><td>is the BAR register the user driver wants to use. </td></tr>
    <tr><td class="paramname">uptr</td><td>is a pointer to the function callbacks in the user driver. </td></tr>
    <tr><td class="paramname">pktsize</td><td>is the size of packets that the user driver will normally use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL incase of any error in completing the registration. </dd>
<dd>
Handle with which the user driver is registered.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should not be called in an interrupt context </dd></dl>

<p>References <a class="el" href="structprivData.html#a40afec97f1c7a5c5e2a19295ba98c065">privData::baseVAddr</a>, <a class="el" href="structDma__Engine.html#a908c7a2313424f11f5b61ba6bc3bdffc">Dma_Engine::BdRing</a>, <a class="el" href="xdma_8h.html#ad5d703a389553efc7322a29711908ca4">descriptor_init()</a>, <a class="el" href="structprivData.html#a59eae8337eabcc719546fee384d49125">privData::Dma</a>, <a class="el" href="xdma__bdring_8c.html#a77800843381096be543f854420a69769">Dma_BdRingStart()</a>, <a class="el" href="xdma__hw_8h.html#a0e996a77348306cfcd58d44ffbe48b34">Dma_mEngIntEnable</a>, <a class="el" href="xdma_8h.html#aafe97d27b1b23279ec57b4c8f64d2369">dmaData</a>, <a class="el" href="structprivData.html#a1df10acd92546ec98acad78242562c55">privData::engineMask</a>, <a class="el" href="structDma__Engine.html#a4be2947a1ed70fe05e1f81931718e5b9">Dma_Engine::EngineState</a>, <a class="el" href="xdma__user_8h.html#a05b386d4bad60f6f9236de6d3be866e0">INITIALIZED</a>, <a class="el" href="structDma__Engine.html#adbd482a091cf7cdcd2d7557ac4b4211d">Dma_Engine::pdev</a>, <a class="el" href="structDma__Engine.html#aa18e24638916943b6f77ddb191875525">Dma_Engine::pktSize</a>, <a class="el" href="structUserPtrs.html#afe89e8b90c431ce9f86587b56bfcd096">UserPtrs::privData</a>, <a class="el" href="structDma__Engine.html#a889ac212be067804cbec378b90a3c6a1">Dma_Engine::user</a>, <a class="el" href="xdma__user_8h.html#a9c24e8534e32ca5c349ed6b2c6ce1609">USER_ASSIGNED</a>, <a class="el" href="structprivData.html#a3145a5b450841717375c78636306557e">privData::userCount</a>, <a class="el" href="structUserPtrs.html#ac49aa8a8d59b855f685b8e0822b2f483">UserPtrs::UserInit</a>, and <a class="el" href="structUserPtrs.html#aa0d8cf9ac553db4da5e279597296b586">UserPtrs::versionReg</a>.</p>

</div>
</div>
<a class="anchor" id="a4104c7117330f48cb334c5c08538ad8e"></a><!-- doxytag: member="xdma_user.h::DmaUnregister" ref="a4104c7117330f48cb334c5c08538ad8e" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DmaUnregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function must be called by the user driver to unregister itself from the base DMA driver. After doing required checks to verify the handle and engine state, the DMA engine is reset, interrupts are disabled if required, and the BD ring is freed, while returning all the packet buffers to the user driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>is the handle which was assigned during the registration process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_FAILURE incase of any error </dd>
<dd>
0 incase of success</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should not be called in an interrupt context </dd></dl>

<p>References <a class="el" href="xdma_8h.html#a81c8783e19a2f1f2c50f8273b286c50d">descriptor_free()</a>, <a class="el" href="xdma_8c.html#aa95c53b30b03661caea5e5c1279acd58">Dma_Reset()</a>, <a class="el" href="xdma_8h.html#aafe97d27b1b23279ec57b4c8f64d2369">dmaData</a>, <a class="el" href="structDma__Engine.html#a4be2947a1ed70fe05e1f81931718e5b9">Dma_Engine::EngineState</a>, <a class="el" href="xdma__user_8h.html#a05b386d4bad60f6f9236de6d3be866e0">INITIALIZED</a>, <a class="el" href="structDma__Engine.html#adbd482a091cf7cdcd2d7557ac4b4211d">Dma_Engine::pdev</a>, <a class="el" href="xdma__user_8h.html#af633e59bd3235afc0e3ce5bb08376e39">UNREGISTERING</a>, <a class="el" href="xdma__user_8h.html#a9c24e8534e32ca5c349ed6b2c6ce1609">USER_ASSIGNED</a>, and <a class="el" href="structprivData.html#a3145a5b450841717375c78636306557e">privData::userCount</a>.</p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2012 18:55:49 for Kintex-7 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
